
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AeroVario Pro (Vanilla)</title>
    
    <!-- 1. LEAFLET CSS (FIRST) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <style>
        /* --- RESET & CORE STYLES --- */
        :root {
            --neon-green: #a3e635;
            --neon-red: #ef4444;
            --neon-purple: #d8b4fe;
            --neon-blue: #3b82f6;
            --neon-cyan: #06b6d4;
            --neon-yellow: #facc15;
            --bg-color: #000000;
            --panel-bg: #111827;
            --text-white: #f3f4f6;
            --text-gray: #9ca3af;
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-white);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- UTILITIES --- */
        .hidden { display: none !important; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .w-full { width: 100%; }
        .font-mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
        .font-bold { font-weight: 700; }
        .absolute { position: absolute; }
        .relative { position: relative; }

        /* --- SCREENS --- */
        #screen-start, #screen-hud {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            transition: opacity 0.3s ease;
        }

        /* --- GLOBAL SETTINGS BUTTON --- */
        #btn-settings {
            position: fixed;
            left: 16px; /* Match top-bar padding */
            top: calc(env(safe-area-inset-top) + 7px);
            z-index: 1000; /* High visibility, but below Modals (2000) */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        /* --- START SCREEN --- */
        .start-btn {
            background: var(--neon-green);
            color: black;
            border: none;
            padding: 20px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(163, 230, 53, 0.4);
            transition: transform 0.1s;
        }
        .start-btn:active { transform: scale(0.95); }
        .secondary-btn {
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            padding: 12px 24px;
            border-radius: 12px;
            margin-top: 10px;
            cursor: pointer;
            width: 200px;
        }

        /* --- HUD COMPONENTS --- */
        .top-bar {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: flex-end; /* Push Mute to right */
            padding: 0 16px;
            font-size: 0.7rem;
            color: var(--text-gray);
            border-bottom: 1px solid #333;
            flex-shrink: 0;
            position: relative;
            padding-top: env(safe-area-inset-top);
            height: calc(50px + env(safe-area-inset-top));
        }

        .status-group { 
            display: flex; gap: 10px; font-weight: bold; 
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 15px; 
        }

        .status-badge { padding: 4px 6px; border-radius: 4px; transition: color 0.3s; border: 1px solid transparent; }
        .status-badge.error-clickable {
            background: rgba(239, 68, 68, 0.2); border-color: var(--neon-red); animation: pulse-border 2s infinite; cursor: pointer;
        }

        .icon-btn {
            background: #1f2937; border: none; color: white; width: 36px; height: 36px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 1rem; cursor: pointer;
            border: 1px solid #374151;
        }

        /* Main Layout */
        .hud-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 8px;
            overflow: hidden;
        }

        /* Section 1: Vario & Horizon (Top Area) */
        .vario-section { 
            display: flex; 
            height: 140px; 
            gap: 8px; 
            flex-shrink: 0; 
        }

        /* Vario Bar */
        .vario-container {
            width: 30px; background: #1f2937; border-radius: 15px; position: relative; overflow: hidden; border: 1px solid #374151;
        }
        .vario-center-line {
            position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background: rgba(255,255,255,0.3); z-index: 10;
        }
        .vario-bar {
            position: absolute; left: 0; width: 100%;
            transition: height 0.1s linear, top 0.1s linear, bottom 0.1s linear, background-color 0.2s;
        }
        .tick { position: absolute; right: 0; width: 6px; height: 1px; background: #666; }

        /* Split Container for Vario Number and Horizon */
        .vario-split-container {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        /* Digital Vario Box (Left Half) */
        .digital-vario-box {
            flex: 1; background: rgba(17, 24, 39, 0.6); border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border: 1px solid #374151; position: relative; padding: 5px;
        }
        #value-vario { font-size: 3.5rem; font-weight: 800; letter-spacing: -2px; line-height: 1; margin-top: 5px; }
        .climbing { color: var(--neon-green); }
        .sinking { color: var(--neon-red); }

        /* --- iOS STYLE COMPASS WIDGET --- */
        .ios-compass-container {
            flex: 1;
            background: #000;
            border-radius: 12px;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .ios-lubber-line {
            position: absolute;
            top: 5px; left: 50%; transform: translateX(-50%);
            width: 0; height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 8px solid white;
            z-index: 20;
        }

        .ios-center-crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 14px; height: 14px;
            margin-top: -7px; margin-left: -7px;
            pointer-events: none;
            z-index: 15;
        }
        .ios-center-crosshair::before {
            content: ''; position: absolute; top: 6px; left: 0; width: 14px; height: 2px; background: rgba(255,255,255,0.4);
        }
        .ios-center-crosshair::after {
            content: ''; position: absolute; left: 6px; top: 0; width: 2px; height: 14px; background: rgba(255,255,255,0.4);
        }

        .ios-compass-card {
            width: 120px; height: 120px;
            position: absolute;
            top: 50%; left: 50%;
            margin-top: -60px; margin-left: -60px;
            will-change: transform;
        }

        .ios-level-pilot {
            position: absolute;
            top: 50%; left: 50%;
            margin-top: -15px; margin-left: -15px;
            width: 30px; height: 30px;
            z-index: 10;
            will-change: transform;
            /* Default centered */
        }
        
        /* Small digital readout inside the compass */
        .ios-hdg-readout {
            position: absolute;
            bottom: 4px; left: 50%; transform: translateX(-50%);
            font-family: -apple-system, sans-serif;
            font-size: 10px; color: #888; font-weight: 500;
        }

        /* --- VISUALIZATION AREA (UNIFIED MAP + ALT GRAPH) --- */
        .vis-container {
            flex: 2; /* Main area */
            display: flex;
            flex-direction: column;
            position: relative; 
            border: 1px solid #374151; 
            border-top: 1px solid var(--neon-green);
            background: #000; 
            border-radius: 12px; 
            overflow: hidden; 
            min-height: 30vh;
        }

        #map-wrapper { flex: 1; width: 100%; position: relative; z-index: 10; }
        #map { width: 100%; height: 100%; background: #111; z-index: 1; }
        
        /* Dark Mode Map Filter */
        .leaflet-tile-pane { filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%); }
        .leaflet-marker-icon { filter: none; }
        .leaflet-control-container .leaflet-top { top: 10px; }
        .leaflet-control-container .leaflet-bottom { bottom: 10px; }
        
        /* Wind Widget on Map */
        .wind-map-widget {
            background: rgba(0,0,0,0.6);
            border: 1px solid #444;
            border-radius: 8px;
            width: 50px; height: 50px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
            backdrop-filter: blur(2px);
        }
        .wind-arrow {
            font-size: 24px; font-weight: bold;
            display: inline-block;
            transition: transform 0.5s ease-out;
        }
        .wind-val { font-size: 9px; font-weight: bold; font-family: monospace; margin-top: -2px; }

        /* Alt Graph (Bottom Strip) */
        .alt-graph-section {
            height: 60px; /* Slightly smaller to give map more room */
            width: 100%;
            border-top: 1px solid #1f2937;
            background: #050505;
            position: relative;
            flex-shrink: 0;
            z-index: 20;
        }
        #alt-graph { width: 100%; height: 100%; }
        /* Label moved to right */
        .graph-label { position: absolute; top: 2px; right: 4px; font-size: 9px; color: #4b5563; font-weight: bold; pointer-events: none; }

        /* Info Grid - DYNAMIC SLOTS */
        .info-grid {
            height: auto; 
            min-height: 200px;
            display: grid; 
            grid-template-columns: 1fr 1fr; /* 2 Columns */
            grid-template-rows: auto auto auto; /* 3 Rows */
            gap: 8px; 
            flex-shrink: 0;
            padding-bottom: 8px;
        }
        .card {
            background: var(--panel-bg); border-radius: 8px; padding: 6px;
            display: flex; flex-direction: column; justify-content: space-between; border: 1px solid #374151;
            min-height: 60px;
        }
        .card-wide { grid-column: span 2; }
        .label { font-size: 0.65rem; text-transform: uppercase; color: var(--text-gray); }
        .value { font-size: 1.4rem; font-weight: bold; text-align: right; }
        .unit { font-size: 0.65rem; color: var(--text-gray); text-align: right; }

        #btn-stop {
            background: rgba(239, 68, 68, 0.2); border: 1px solid var(--neon-red); color: var(--neon-red);
            padding: 12px; border-radius: 12px; font-weight: bold; text-transform: uppercase;
            width: calc(100% - 16px); margin: 0 8px 8px 8px; flex-shrink: 0;
        }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000; /* Higher than map */
            display: flex; flex-direction: column; padding: 20px; overflow-y: auto;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .modal-title { font-size: 1.2rem; font-weight: bold; color: var(--neon-green); }
        
        /* SETTINGS STYLES */
        .setting-group { background: #1f2937; padding: 15px; border-radius: 10px; margin-bottom: 10px; border: 1px solid #374151; }
        .setting-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .setting-inputs { border-top: 1px solid #374151; padding-top: 10px; margin-top: 10px; }
        .input-row { display: flex; justify-content: space-between; align-items: center; margin-top: 8px; }
        .input-row label { font-size: 0.8rem; color: #9ca3af; }
        
        input[type="number"], select { background: #000; color: white; border: 1px solid #4b5563; padding: 6px; border-radius: 6px; width: 120px; text-align: right; }

        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--neon-green); }
        input:checked + .slider:before { transform: translateX(16px); }
        
        /* LAYOUT CONFIG */
        .layout-grid-config { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .layout-slot { background: #111; padding: 8px; border-radius: 6px; border: 1px dashed #4b5563; }
        .slot-label { font-size: 0.7rem; color: var(--neon-blue); margin-bottom: 4px; display:block; }
        .slot-select { width: 100%; font-size: 0.8rem; text-align: left; }

        /* LOG STYLES - ADVANCED */
        .log-item { background: #1f2937; border: 1px solid #374151; border-radius: 10px; margin-bottom: 12px; overflow: hidden; transition: all 0.2s; }
        .log-summary { 
            padding: 12px; display: flex; justify-content: space-between; align-items: center; cursor: pointer;
            background: linear-gradient(90deg, #1f2937 0%, #111827 100%);
        }
        .log-summary:active { background: #374151; }
        
        .log-date { color: white; font-weight: bold; font-size: 0.95rem; }
        .log-basic-stats { font-size: 0.75rem; color: #9ca3af; margin-top: 4px; display: flex; gap: 10px; }
        
        .log-details { 
            padding: 12px; background: #0b0f19; border-top: 1px solid #374151; 
            display: none; animation: slideDown 0.2s ease-out;
        }
        .log-details.open { display: block; }
        
        /* STATS GRID STYLES */
        .stats-section-title {
            color: #6b7280; font-size: 0.8rem; font-weight: bold; margin: 10px 0 6px 0; border-bottom: 1px solid #374151; padding-bottom: 4px;
        }
        .stats-grid-2col {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;
        }
        .stat-item {
            display: flex; flex-direction: column;
        }
        .stat-val {
            font-size: 1.1rem; color: #fff; font-weight: 600; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
        }
        .stat-lbl {
            font-size: 0.75rem; color: #9ca3af; margin-top: 2px; display: flex; align-items: center; gap: 4px;
        }

        .btn-map-view {
            width: 100%; background: rgba(59, 130, 246, 0.2); color: #60a5fa; border: 1px solid #2563eb;
            padding: 10px; border-radius: 8px; margin-top: 10px; font-weight: bold; font-size: 0.8rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;
        }

        .btn-download-igc {
            width: 100%; background: rgba(163, 230, 53, 0.2); color: #a3e635; border: 1px solid #65a30d;
            padding: 10px; border-radius: 8px; margin-top: 10px; font-weight: bold; font-size: 0.8rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px;
        }

        .btn-delete-log {
            background: none; border: none; font-size: 1.2rem; cursor: pointer; opacity: 0.7; padding: 8px; color: #ef4444;
        }

        .btn-delete-all {
            background: rgba(239, 68, 68, 0.1); border: 1px solid #7f1d1d; color: #ef4444;
            padding: 12px; width: 100%; border-radius: 8px; margin-top: 20px;
            cursor: pointer; font-weight: bold; text-transform: uppercase; font-size: 0.8rem;
        }

        /* Review Map specific */
        #review-map-container {
            flex: 1; border-radius: 12px; border: 1px solid #374151; overflow: hidden; background: #111;
        }

        /* METEO STYLES */
        .meteo-card {
            background: #111827; border: 1px solid #374151; border-radius: 12px; padding: 15px; margin-bottom: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;
        }
        .meteo-wind-circle {
            width: 80px; height: 80px; border: 2px solid #374151; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; position: relative;
            background: radial-gradient(circle, #1f2937 0%, #000 100%);
            margin-bottom: 10px;
        }
        .wind-arrow-icon {
            font-size: 2rem; color: var(--neon-cyan); transition: transform 0.5s ease-out;
        }
        .meteo-location {
            font-size: 1rem; color: #f3f4f6; margin-bottom: 15px; font-weight: bold; text-align: center;
        }
        
        /* EXPERT PANEL STYLES */
        .expert-card {
            width: 100%; background: #0f172a; border: 1px solid #334155; border-radius: 12px; 
            padding: 15px; margin-bottom: 15px; display: flex; flex-direction: column;
        }
        .expert-header {
            font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .status-bar {
            height: 6px; width: 100%; background: #334155; border-radius: 3px; margin-bottom: 10px;
            overflow: hidden;
        }
        .status-fill {
            height: 100%; width: 100%; transition: background-color 0.5s, width 0.5s;
        }
        .expert-text {
            font-size: 0.95rem; line-height: 1.4; font-weight: 600; color: #f1f5f9;
        }

        .meteo-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }

        /* Meteo External Links */
        .meteo-links {
            width: 100%; margin-top: 20px; border-top: 1px solid #374151; padding-top: 15px;
        }
        .links-title { font-size: 0.8rem; text-transform: uppercase; color: #6b7280; margin-bottom: 10px; text-align: center; }
        .links-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .link-btn {
            background: #1f2937; color: #60a5fa; border: 1px solid #374151;
            padding: 10px; border-radius: 8px; text-align: center; text-decoration: none;
            font-weight: bold; font-size: 0.85rem; transition: background 0.2s;
        }
        .link-btn:active { background: #374151; }

        @keyframes slideDown { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        
        /* CALIBRATION OVERLAY */
        .calibration-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9000;
            display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center;
            padding: 20px;
        }
        .cal-spinner { width:40px; height:40px; border:4px solid #374151; border-top:4px solid var(--neon-green); border-radius:50%; animation:spin 1s linear infinite; margin-bottom:20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .cal-bar-container { width:80%; height:6px; background:#333; border-radius:3px; margin-top:15px; overflow:hidden; }
        .cal-bar { height:100%; width:0%; background:var(--neon-green); transition:width 0.1s linear; }

        #alert-overlay {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: var(--neon-red); color: black; padding: 8px 16px;
            border-radius: 20px; font-weight: bold; z-index: 50;
            box-shadow: 0 0 15px var(--neon-red); display: none;
            animation: pulse 0.5s infinite alternate; width: 80%; text-align: center;
        }

        @keyframes pulse { from { opacity: 0.8; } to { opacity: 1; transform: translateX(-50%) scale(1.05); } }
        @keyframes pulse-border { 0% { border-color: var(--neon-red); } 50% { border-color: transparent; } 100% { border-color: var(--neon-red); } }
        .safe-area { padding-bottom: env(safe-area-inset-bottom); }
    </style>
    
    <!-- 2. LEAFLET JS (SECOND) -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0"
  }
}
</script>
</head>
<body>

    <!-- GLOBAL SETTINGS BUTTON -->
    <button id="btn-settings" class="icon-btn">‚öôÔ∏è</button>

    <!-- === START SCREEN === -->
    <div id="screen-start" class="flex flex-col items-center justify-center relative">
        <div style="position:absolute; top:0; width:100%; height:30%; background:radial-gradient(circle at top, rgba(163,230,53,0.1), transparent);"></div>
        <h1 style="font-size: 3rem; margin-bottom: 0;">AERO<span style="color:var(--neon-green)">VARIO</span></h1>
        <p style="color:var(--text-gray); letter-spacing: 2px; font-size: 0.8rem; margin-bottom: 40px;">PRO FLIGHT INSTRUMENT</p>
        <button id="btn-start" class="start-btn">INICIAR VUELO</button>
        <button id="btn-meteo" class="secondary-btn">‚òÅÔ∏è Ver Previsi√≥n</button>
        <button id="btn-logs" class="secondary-btn">Historial</button>
        <div id="error-console" style="margin-top: 20px; color: red; font-size: 10px; max-width: 90%; white-space: pre-wrap;"></div>
        <p style="position:absolute; bottom:20px; left:20px; font-size:10px; color:#4b5563; opacity:0.7;">Created by: Spaciodnso</p>
    </div>

    <!-- === HUD SCREEN === -->
    <div id="screen-hud" class="hidden flex-col safe-area relative">
        <div id="alert-overlay">‚ö†Ô∏è ALARM</div>

        <!-- CALIBRATION OVERLAY -->
        <div id="calibration-overlay" class="calibration-overlay hidden">
            <div class="cal-spinner"></div>
            <h2 style="color:var(--neon-green); margin-bottom:5px;">CALIBRANDO</h2>
            <p style="color:#9ca3af; font-size:0.9rem;">Mant√©n el dispositivo quieto...</p>
            <div class="cal-bar-container"><div id="cal-bar" class="cal-bar"></div></div>
        </div>

        <!-- Top Bar -->
        <div class="top-bar">
            <!-- Settings button moved to global body -->
            <div class="status-group">
                <div id="gps-status" class="status-badge" style="color: #eab308;">GPS: Inic...</div>
                <div id="sat-status" class="status-badge" style="color: #4b5563;">SAT: --</div>
                <div id="compass-status" class="status-badge" style="color: #4b5563;">MAG: --</div>
            </div>
            <button id="btn-mute" class="icon-btn">üîä</button>
        </div>

        <div class="hud-content">
            <!-- Section 1: Vario & Horizon -->
            <div class="vario-section">
                <!-- Left Bar -->
                <div class="vario-container">
                    <div class="vario-center-line"></div>
                    <div id="vario-fill" class="vario-bar" style="height: 0; top: 50%;"></div>
                    <div id="ticks-container"></div>
                </div>
                
                <!-- Split Display: Number & Compass -->
                <div class="vario-split-container">
                    <!-- Digital Number -->
                    <div class="digital-vario-box">
                        <span style="color:#6b7280; font-size:0.6rem; position:absolute; top:5px;">VARIO m/s</span>
                        <span id="value-vario" class="font-mono">+0.0</span>
                    </div>

                    <!-- iOS COMPASS WIDGET (REBUILT) -->
                    <div class="ios-compass-container">
                        <!-- Fixed Lubber Line (Top) -->
                        <div class="ios-lubber-line"></div>
                        
                        <!-- Rotating Compass Card -->
                        <div id="ios-compass-card" class="ios-compass-card">
                            <svg viewBox="0 0 100 100" width="100%" height="100%">
                                <!-- Ticks generation: We need multiple lines.
                                     Major ticks every 30 deg (long)
                                     Minor ticks every 2 deg (short) - optional, maybe just every 10 for performance.
                                     Let's use a simpler static SVG for the card to ensure high performance rotation.
                                -->
                                <!-- Outer circle guide -->
                                <!-- <circle cx="50" cy="50" r="48" stroke="#333" stroke-width="0.5" fill="none"/> -->
                                
                                <!-- Major Ticks (N, E, S, W + 30, 60...) -->
                                <line x1="50" y1="2" x2="50" y2="8" stroke="white" stroke-width="2"/> <!-- N -->
                                <line x1="50" y1="92" x2="50" y2="98" stroke="white" stroke-width="2"/> <!-- S -->
                                <line x1="92" y1="50" x2="98" y2="50" stroke="white" stroke-width="2"/> <!-- E -->
                                <line x1="2" y1="50" x2="8" y2="50" stroke="white" stroke-width="2"/> <!-- W -->

                                <!-- 30 deg ticks -->
                                <g transform="rotate(30, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(60, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(120, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(150, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(210, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(240, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(300, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>
                                <g transform="rotate(330, 50, 50)"><line x1="50" y1="2" x2="50" y2="7" stroke="#999" stroke-width="1.5"/></g>

                                <!-- Minor Ticks every 10 degrees (excluding 30s) -->
                                <g transform="rotate(10, 50, 50)"><line x1="50" y1="2" x2="50" y2="5" stroke="#555" stroke-width="1"/></g>
                                <g transform="rotate(20, 50, 50)"><line x1="50" y1="2" x2="50" y2="5" stroke="#555" stroke-width="1"/></g>
                                <g transform="rotate(40, 50, 50)"><line x1="50" y1="2" x2="50" y2="5" stroke="#555" stroke-width="1"/></g>
                                <g transform="rotate(50, 50, 50)"><line x1="50" y1="2" x2="50" y2="5" stroke="#555" stroke-width="1"/></g>
                                <!-- ... repeating for all is tedious in static HTML, keeping it cleaner with just 10s visual filler if needed, but 30s is standard for clear reading on small widgets -->

                                <!-- Labels -->
                                <text x="50" y="22" font-family="-apple-system, sans-serif" font-size="14" fill="#fff" text-anchor="middle" font-weight="500">N</text>
                                <text x="50" y="88" font-family="-apple-system, sans-serif" font-size="12" fill="#fff" text-anchor="middle">S</text>
                                <text x="86" y="54" font-family="-apple-system, sans-serif" font-size="12" fill="#fff" text-anchor="middle">E</text>
                                <text x="14" y="54" font-family="-apple-system, sans-serif" font-size="12" fill="#fff" text-anchor="middle">W</text>
                            </svg>
                        </div>

                        <!-- Fixed Level Crosshair -->
                        <div class="ios-center-crosshair"></div>

                        <!-- Moving Paraglider Bubble -->
                        <div id="ios-level-pilot" class="ios-level-pilot">
                            <svg viewBox="0 0 100 100" width="100%" height="100%">
                                <path d="M10,40 Q50,5 90,40" fill="none" stroke="white" stroke-width="3" stroke-linecap="round"/>
                                <line x1="10" y1="40" x2="50" y2="70" stroke="white" stroke-width="1"/>
                                <line x1="90" y1="40" x2="50" y2="70" stroke="white" stroke-width="1"/>
                                <circle cx="50" cy="70" r="6" fill="white"/>
                            </svg>
                        </div>
                        
                        <!-- Heading Readout -->
                        <div class="ios-hdg-readout"><span id="val-hdg-ios">0</span>¬∞</div>
                    </div>
                </div>
            </div>

            <!-- Section 2: Unified Visual Container -->
            <div class="vis-container">
                <!-- Leaflet Map (Unified) -->
                <div id="map-wrapper">
                    <div id="map"></div>
                </div>

                <!-- Altitude Graph (Bottom Strip) -->
                <div class="alt-graph-section">
                    <canvas id="alt-graph"></canvas>
                    <span class="graph-label">ALT HISTORY (2m)</span>
                </div>
            </div>

            <!-- Section 3: Dynamic Grid Info (Inject via JS) -->
            <div id="dashboard-grid" class="info-grid">
                <!-- JavaScript will populate this based on layout config -->
            </div>
        </div>

        <button id="btn-stop">Finalizar Vuelo</button>
    </div>

    <!-- === SETTINGS MODAL === -->
    <div id="modal-settings" class="modal-overlay hidden">
        <div class="modal-header">
            <span class="modal-title">Configuraci√≥n</span>
            <button class="icon-btn" onclick="toggleModal('modal-settings', false)">‚úï</button>
        </div>
        <div id="settings-content"></div>
        <button onclick="saveSettingsAndClose()" class="start-btn w-full" style="margin-top:20px; padding:10px;">Guardar y Cerrar</button>
    </div>

    <!-- === LOGS MODAL === -->
    <div id="modal-logs" class="modal-overlay hidden">
        <div class="modal-header">
            <span class="modal-title">Historial de Vuelos</span>
            <button class="icon-btn" onclick="toggleModal('modal-logs', false)">‚úï</button>
        </div>
        <div id="logs-list" class="w-full"></div>
    </div>
    
    <!-- === METEO MODAL === -->
    <div id="modal-meteo" class="modal-overlay hidden">
        <div class="modal-header">
            <span class="modal-title">An√°lisis Meteo</span>
            <button class="icon-btn" onclick="toggleModal('modal-meteo', false)">‚úï</button>
        </div>
        <div id="meteo-content" class="w-full flex flex-col items-center">
            <div id="meteo-loading" style="color:#9ca3af; margin-top:20px;">Esperando ubicaci√≥n...</div>
            
            <div id="meteo-data" class="w-full hidden">
                
                <div id="meteo-location-display" class="meteo-location"></div>

                <!-- Expert Panel -->
                <div class="expert-card">
                    <div class="expert-header">
                        <span>üß† Opini√≥n del Instructor</span>
                        <span id="expert-badge"></span>
                    </div>
                    <div class="status-bar">
                        <div id="expert-bar-fill" class="status-fill" style="background:gray; width:100%"></div>
                    </div>
                    <div id="expert-text" class="expert-text">
                        Calculando viabilidad...
                    </div>
                </div>

                <div class="meteo-card">
                    <div class="meteo-wind-circle">
                        <div id="wind-arrow" class="wind-arrow-icon">‚¨á</div>
                        <span style="position:absolute; top:2px; font-size:0.6rem; color:#6b7280;">N</span>
                    </div>
                    <div class="text-center">
                        <div style="font-size:0.8rem; color:#9ca3af;">VIENTO</div>
                        <div class="font-mono" style="font-size:1.5rem; font-weight:bold; color:var(--neon-cyan);">
                            <span id="val-wind">0</span> <span style="font-size:0.8rem;">km/h</span>
                        </div>
                        <div style="font-size:0.8rem; color:var(--neon-red); margin-top:4px;">
                            R√°fagas: <span id="val-gusts">0</span>
                        </div>
                    </div>
                </div>

                <div class="meteo-grid">
                    <div class="meteo-card">
                        <div class="label">Temperatura</div>
                        <div class="value font-mono"><span id="val-temp">0</span>¬∞C</div>
                    </div>
                    <div class="meteo-card">
                        <div class="label">Nubes</div>
                        <div class="value font-mono"><span id="val-cloud">0</span>%</div>
                    </div>
                </div>
                
                <div style="font-size:0.7rem; color:#4b5563; text-align:center; margin-top:10px;">
                    Fuente: Open-Meteo API
                </div>

                <div class="meteo-links">
                    <div class="links-title">Enlaces Meteo Espa√±a</div>
                    <div class="links-grid">
                        <a href="https://www.eltiempo.es" target="_blank" class="link-btn">ElTiempo.es</a>
                        <a href="http://www.aemet.es" target="_blank" class="link-btn">AEMET</a>
                        <a href="https://www.windy.com" target="_blank" class="link-btn">Windy</a>
                        <a href="https://www.meteoblue.com" target="_blank" class="link-btn">MeteoBlue</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- === REVIEW MAP MODAL === -->
    <div id="modal-review" class="modal-overlay hidden">
        <div class="modal-header">
            <span class="modal-title">Ruta de Vuelo</span>
            <button class="icon-btn" onclick="closeReviewMap()">‚úï</button>
        </div>
        <div id="review-map-container"></div>
        <div style="text-align:center; font-size:10px; color:#666; margin-top:5px;">Cyan: Ruta de Vuelo</div>
    </div>

    <!-- === JAVASCRIPT LOGIC === -->
    <script>
        const $ = (id) => document.getElementById(id);
        window.onerror = (msg, url, line) => $('error-console').innerText += `\nERR: ${msg}`;

        // --- WIDGET REGISTRY (DATA LIBRARY) ---
        const WIDGETS_REGISTRY = {
            'alt': { label: 'ALTITUD', unit: 'm', id: 'value-alt' },
            'rel': { label: 'ALT RELATIVA', unit: 'm', id: 'value-rel-alt' },
            'spd': { label: 'VELOCIDAD', unit: 'km/h', id: 'value-speed' },
            'gld': { label: 'PLANEO', unit: 'L/D', id: 'value-glide' },
            'tim': { label: 'TIEMPO', unit: '', id: 'value-time' },
            'dst': { label: 'DISTANCIA', unit: 'km', id: 'value-dist' },
            'hdg': { label: 'RUMBO', unit: '¬∞', id: 'value-hdg' },
            'empty': { label: 'VAC√çO', unit: '', id: null }
        };

        // --- STATE ---
        const DEFAULT_SETTINGS = {
            alerts: [
                { id: 'low_alt', type: 'ALTITUDE_LOW', enabled: false, threshold: 1000, sound: 'beep' },
                { id: 'sink_alarm', type: 'SINK_RATE', enabled: true, threshold: -2.5, duration: 2, sound: 'siren' }
            ],
            liftThreshold: 0.2, // Default Start Beeping at +0.2 m/s
            sinkThreshold: -2.0 // Default Start Buzzing at -2.0 m/s
        };
        
        let appState = {
            flying: false, calibrating: false, muted: false, startTime: 0,
            flightData: { alt: 0, vario: 0, speed: 0, glide: 0, relAlt: 0, heading: 0, lat: 0, lon: 0, totalDistance: 0 },
            sensors: { 
                magHeading: 0, 
                pitch: 0, roll: 0, // Current raw
                smoothPitch: 0, smoothRoll: 0, smoothHeading: 0 // Smoothed values
            },
            stats: { maxAlt: -9999, maxClimb: 0, maxSink: 0, maxSpeed: 0 },
            takeoffAlt: null,
            settings: { ...DEFAULT_SETTINGS, ...JSON.parse(localStorage.getItem('av_settings') || '{}') }, // Merge Defaults with Local
            layout: JSON.parse(localStorage.getItem('av_layout')) || ['alt', 'spd', 'gld', 'tim', 'dst', 'hdg'], // Default Grid
            fullTrack: [],    
            altHistory: [], 
            startLocation: null, 
            mapThermalMarkers: [],
            lastOdometerPos: null,
            calibrationBuffer: [], // To store alt readings during warm-up
            windEstimator: null // Will instantiate WindEstimator
        };
        
        // --- ANIMATION LOOP FOR COMPASS (60FPS) ---
        function animateCompass() {
            if (!appState.flying && !appState.calibrating) {
                requestAnimationFrame(animateCompass);
                return;
            }

            // Smoothing Factors (LERP)
            const factor = 0.1;
            
            // 1. Smooth Sensors
            // Heading wrap-around logic is needed for perfect 360->0 smoothing, 
            // but simple lerp works ok for most cases except North crossing.
            // Using a specialized lerpAngle function for heading.
            appState.sensors.smoothHeading = lerpAngle(appState.sensors.smoothHeading, appState.sensors.magHeading, factor);
            
            appState.sensors.smoothPitch = lerp(appState.sensors.smoothPitch, appState.sensors.pitch, factor);
            appState.sensors.smoothRoll = lerp(appState.sensors.smoothRoll, appState.sensors.roll, factor);

            // 2. Rotate Compass Card
            // Inverse rotation so North points North relative to screen
            const card = $('ios-compass-card');
            if (card) {
                card.style.transform = `rotate(${-appState.sensors.smoothHeading}deg)`;
            }
            
            // 3. Move Pilot Bubble (Level)
            // Roll (Gamma) moves X. Tilt Left (Neg) -> Move Left (Neg)
            // Pitch (Beta) moves Y. Tilt Forward (Pos) -> Move Up (Neg)? 
            // Standard: Tilt forward (top down) -> Bubble goes UP.
            // Beta > 0 is sitting up/tilting back usually? depends on device orientation.
            // In landscape/portrait held up:
            // Beta is front/back tilt. 
            // Let's assume holding phone flat:
            // Tilt phone forward (top goes down) -> Beta increases?
            // Actually, let's just map straightforward and user can calibrate mental model.
            
            const maxOffset = 35; // px limit
            const x = Math.max(-maxOffset, Math.min(maxOffset, appState.sensors.smoothRoll * 1.5)); // 1.5 multiplier for sensitivity
            const y = Math.max(-maxOffset, Math.min(maxOffset, appState.sensors.smoothPitch * 1.5));

            const pilot = $('ios-level-pilot');
            if (pilot) {
                pilot.style.transform = `translate(${x}px, ${y}px)`;
            }

            // 4. Update Readout
            const readout = $('val-hdg-ios');
            if(readout) readout.innerText = Math.round(appState.sensors.smoothHeading);

            requestAnimationFrame(animateCompass);
        }

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // Handles the 359 -> 1 degree wrap around smoothly
        function lerpAngle(start, end, amt) {
            let difference = Math.abs(end - start);
            if (difference > 180) {
                // We need to add on to one of the values.
                if (end > start) {
                    start += 360;
                } else {
                    end += 360;
                }
            }
            let value = (start + ((end - start) * amt));
            if (value >= 0 && value <= 360) return value;
            return value % 360;
        }

        // Start animation loop once
        requestAnimationFrame(animateCompass);


        // --- WIND ESTIMATOR CLASS ---
        class WindEstimator {
            constructor() {
                this.buffer = []; // {heading, speed, timestamp}
                this.windowSize = 45000; // 45 seconds buffer
                this.minSpeed = 5; // Min speed to consider (km/h)
                this.lastWind = { direction: 0, speed: 0, valid: false };
            }
            
            add(heading, speed, timestamp) {
                if (speed < this.minSpeed) return;
                this.buffer.push({ h: heading, s: speed, t: timestamp });
                // Prune
                const cutoff = timestamp - this.windowSize;
                while(this.buffer.length > 0 && this.buffer[0].t < cutoff) {
                    this.buffer.shift();
                }
            }
            
            estimate() {
                if (this.buffer.length < 20) return this.lastWind;
                
                // 1. Detect Turn (Check if we covered 4 quadrants)
                let q1=false, q2=false, q3=false, q4=false;
                let maxS = 0; 
                let minS = 999;
                let headingAtMin = 0;

                this.buffer.forEach(p => {
                    if(p.h >= 0 && p.h < 90) q1=true;
                    if(p.h >= 90 && p.h < 180) q2=true;
                    if(p.h >= 180 && p.h < 270) q3=true;
                    if(p.h >= 270 && p.h < 360) q4=true;
                    
                    if (p.s > maxS) maxS = p.s;
                    if (p.s < minS) { minS = p.s; headingAtMin = p.h; }
                });
                
                // If we have data in at least 3 quadrants, assume a turn
                const quadrants = (q1?1:0)+(q2?1:0)+(q3?1:0)+(q4?1:0);
                
                if (quadrants >= 3) {
                    // Wind Speed = (Vmax - Vmin) / 2
                    // Wind Direction = Heading where ground speed was Minimal (Headwind)
                    const windSpeed = (maxS - minS) / 2;
                    // Filter crazy values
                    if (windSpeed > 0 && windSpeed < 60) {
                        this.lastWind = {
                            speed: Math.round(windSpeed),
                            direction: Math.round(headingAtMin),
                            valid: true
                        };
                    }
                }
                
                return this.lastWind;
            }
        }

        // --- DASHBOARD RENDER LOGIC ---
        function renderDashboard() {
            const grid = $('dashboard-grid');
            if(!grid) return;
            grid.innerHTML = ''; // Clear

            appState.layout.forEach(widgetKey => {
                const w = WIDGETS_REGISTRY[widgetKey] || WIDGETS_REGISTRY['empty'];
                const div = document.createElement('div');
                div.className = 'card';
                
                if (w.id === null) {
                    // Empty Slot
                    div.innerHTML = `<span class="label" style="opacity:0.3">VAC√çO</span>`;
                } else {
                    // Special logic for reset alt click
                    const clickAction = (widgetKey === 'alt' || widgetKey === 'rel') ? 'onclick="resetAlt()"' : '';
                    const cursorStyle = (widgetKey === 'alt' || widgetKey === 'rel') ? 'cursor:pointer' : '';
                    const icon = (widgetKey === 'alt' || widgetKey === 'rel') ? 'üîÑ' : '';
                    
                    div.innerHTML = `
                        <div style="display:flex; justify-content:space-between; ${cursorStyle}" ${clickAction}>
                            <span class="label">${w.label}</span>
                            ${icon ? `<span style="font-size:0.7rem; opacity:0.6">${icon}</span>` : ''}
                        </div>
                        <div>
                            <div id="${w.id}" class="value font-mono">--</div>
                            ${w.unit ? `<div class="unit">${w.unit}</div>` : ''}
                        </div>
                    `;
                }
                grid.appendChild(div);
            });
        }

        // --- FLIGHT TIMER ---
        let flightTimerInterval = null;

        function updateFlightClock() {
            if (!appState.flying) return;
            const diff = Date.now() - appState.startTime;
            
            // Format HH:MM:SS
            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            
            const str = 
                (hours < 10 ? "0" + hours : hours) + ":" +
                (minutes < 10 ? "0" + minutes : minutes) + ":" +
                (seconds < 10 ? "0" + seconds : seconds);
            
            // Safe Update
            const el = $('value-time');
            if(el) el.innerText = str;
        }

        // --- WAKE LOCK MANAGER ---
        let wakeLock = null;

        async function manageWakeLock(shouldLock) {
            if (!('wakeLock' in navigator)) return;

            try {
                if (shouldLock && !wakeLock) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        wakeLock = null;
                    });
                } else if (!shouldLock && wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                }
            } catch (err) {
                console.warn('WakeLock Error:', err);
            }
        }

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && appState.flying) {
                await manageWakeLock(true);
            }
        });

        // --- MAP VARIABLES & ICON ---
        let mapInstance = null;
        let mapMarker = null;
        let mapPolyline = null;
        let isMapCentered = false;
        let windWidgetEl = null;

        const PARAGLIDER_SVG = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
            <path d="M4 24 C4 10 32 4 32 4 C32 4 60 10 60 24 C60 28 54 30 32 26 C10 30 4 28 4 24 Z" fill="#06b6d4" stroke="white" stroke-width="1.5" stroke-linejoin="round"/>
            <path d="M12 26 L28 48 M52 26 L36 48 M32 25 L32 48" stroke="white" stroke-width="1" stroke-linecap="round"/>
            <circle cx="32" cy="50" r="4" fill="#a3e635" stroke="white" stroke-width="1"/>
        </svg>
        `.trim();

        const pilotIcon = L.icon({
            iconUrl: 'data:image/svg+xml;base64,' + btoa(PARAGLIDER_SVG),
            iconSize: [48, 48],
            iconAnchor: [24, 38], 
            popupAnchor: [0, -40]
        });

        // --- MAP INITIALIZATION ---
        function initMap() {
            if (mapInstance) return;
            mapInstance = L.map('map', { zoomControl: false, attributionControl: false }).setView([0, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(mapInstance);
            mapMarker = L.marker([0,0], { icon: pilotIcon, zIndexOffset: 1000 }).addTo(mapInstance);
            mapPolyline = L.polyline([], { color: '#3b82f6', weight: 4, opacity: 0.8 }).addTo(mapInstance);
            
            // Add Wind Widget Control
            const WindControl = L.Control.extend({
                onAdd: function(map) {
                    const div = L.DomUtil.create('div', 'wind-map-widget');
                    div.innerHTML = `<span id="map-wind-arrow" class="wind-arrow" style="opacity:0.3">‚¨Ü</span><span id="map-wind-val" class="wind-val">?</span>`;
                    return div;
                },
                onRemove: function(map) {}
            });
            mapInstance.addControl(new WindControl({ position: 'bottomleft' }));
            
            setTimeout(() => { mapInstance.invalidateSize(); }, 500);
        }

        function updateMap(lat, lon, vario) {
            if (!mapInstance || !lat || !lon) return;
            const latLng = [lat, lon];
            mapMarker.setLatLng(latLng);
            
            // Only add to map path if flying, not calibrating
            if (appState.flying) {
                mapPolyline.addLatLng(latLng);

                let tColor = '#6b7280'; let tRadius = 2; let tOpacity = 0.5;
                if (vario > 2.0) { tColor = '#d8b4fe'; tRadius = 8; tOpacity = 0.9; } 
                else if (vario > 0.5) { tColor = '#ef4444'; tRadius = 6; tOpacity = 0.9; }
                
                const thermalMarker = L.circleMarker(latLng, { color: tColor, fillColor: tColor, fillOpacity: tOpacity, stroke: false, radius: tRadius }).addTo(mapInstance);
                appState.mapThermalMarkers.push(thermalMarker);

                if (appState.mapThermalMarkers.length > 120) {
                    const oldMarker = appState.mapThermalMarkers.shift();
                    mapInstance.removeLayer(oldMarker);
                }
            }

            if (!isMapCentered) { mapInstance.setView(latLng, 17); isMapCentered = true; } 
            else { mapInstance.panTo(latLng); }
        }
        
        function updateWindWidget(windData) {
            const arrow = $('map-wind-arrow');
            const val = $('map-wind-val');
            if (arrow && val) {
                if (windData.valid) {
                    arrow.style.opacity = '1';
                    arrow.style.color = 'var(--neon-green)';
                    arrow.style.transform = `rotate(${windData.direction}deg)`;
                    val.innerText = `${windData.speed} km/h`;
                } else {
                    arrow.style.opacity = '0.3';
                    arrow.style.color = 'white';
                    val.innerText = '?';
                }
            }
        }

        // --- SETTINGS LOGIC ---
        function renderSettings() {
            const container = $('settings-content');
            container.innerHTML = '';

            // 1. DASHBOARD CONFIG SECTION
            let dashboardHtml = `
            <div class="setting-group">
                <div class="setting-header">
                    <span style="color:var(--neon-blue); font-weight:bold;">Personalizar Pantalla</span>
                </div>
                <div class="layout-grid-config">`;
            
            appState.layout.forEach((currentKey, idx) => {
                let optionsHtml = '';
                for (const [key, val] of Object.entries(WIDGETS_REGISTRY)) {
                    optionsHtml += `<option value="${key}" ${key === currentKey ? 'selected' : ''}>${val.label}</option>`;
                }
                
                dashboardHtml += `
                    <div class="layout-slot">
                        <span class="slot-label">Posici√≥n ${idx + 1}</span>
                        <select class="slot-select" onchange="updateLayout(${idx}, this.value)">
                            ${optionsHtml}
                        </select>
                    </div>`;
            });
            dashboardHtml += `</div></div>`;
            container.innerHTML += dashboardHtml;

            // 2. AUDIO THRESHOLDS (VARIO SENSITIVITY) - NEW
            let sensitivityHtml = `
            <div class="setting-group">
                <div class="setting-header">
                    <span style="color:var(--neon-yellow); font-weight:bold;">Sensibilidad del Vario</span>
                </div>
                <div class="setting-inputs">
                    <div class="input-row">
                        <label>Activar Beep Subida (> m/s)</label>
                        <input type="number" step="0.1" min="0.1" max="5.0" value="${appState.settings.liftThreshold || 0.2}" onchange="updateGlobalSetting('liftThreshold', parseFloat(this.value))">
                    </div>
                    <div class="input-row">
                        <label>Alarma de Tasa (> m/s)</label>
                        <input type="number" step="0.1" max="-0.5" min="-10.0" value="${appState.settings.sinkThreshold || -2.0}" onchange="updateGlobalSetting('sinkThreshold', parseFloat(this.value))">
                    </div>
                </div>
            </div>`;
            container.innerHTML += sensitivityHtml;

            // 3. ALERTS CONFIG SECTION
            appState.settings.alerts.forEach((alert) => {
                const isLowAlt = alert.type === 'ALTITUDE_LOW';
                const title = isLowAlt ? '‚ö†Ô∏è Baja Altitud' : '‚¨áÔ∏è Descenso Fuerte';
                const desc = isLowAlt
                    ? "Alerta sonora continua cuando vuelas por debajo de la altura configurada."
                    : "Alarma de seguridad cr√≠tica si tu tasa de ca√≠da supera el l√≠mite establecido.";
                const color = alert.enabled ? 'var(--neon-green)' : '#666';
                
                const html = `
                <div class="setting-group">
                    <div class="setting-header">
                        <span style="color:${color}; font-weight:bold;">${title}</span>
                        <label class="switch">
                            <input type="checkbox" ${alert.enabled ? 'checked' : ''} 
                                onchange="updateSetting('${alert.id}', 'enabled', this.checked)">
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div style="font-size:0.75rem; color:#9ca3af; margin-bottom:12px; margin-top:-8px; line-height:1.3;">
                        ${desc}
                    </div>
                    ${alert.enabled ? `
                    <div class="setting-inputs">
                        <div class="input-row">
                            <label>Umbral (${isLowAlt ? 'm' : 'm/s'})</label>
                            <input type="number" value="${alert.threshold}" step="${isLowAlt?10:0.1}"
                                onchange="updateSetting('${alert.id}', 'threshold', parseFloat(this.value))">
                        </div>
                        ${!isLowAlt ? `
                        <div class="input-row">
                            <label>Duraci√≥n (seg)</label>
                            <input type="number" value="${alert.duration||2}" 
                                onchange="updateSetting('${alert.id}', 'duration', parseFloat(this.value))">
                        </div>` : ''}
                        <div class="input-row">
                            <label>Sonido</label>
                            <select onchange="updateSetting('${alert.id}', 'sound', this.value)">
                                <option value="siren" ${alert.sound==='siren'?'selected':''}>Sirena</option>
                                <option value="beep" ${alert.sound==='beep'?'selected':''}>Beep</option>
                                <option value="whoop" ${alert.sound==='whoop'?'selected':''}>Whoop</option>
                                <option value="flatline" ${alert.sound==='flatline'?'selected':''}>Plano</option>
                            </select>
                        </div>
                    </div>` : ''}
                </div>`;
                container.innerHTML += html;
            });
        }

        window.updateLayout = (index, key) => {
            appState.layout[index] = key;
        };

        window.updateSetting = (id, field, value) => {
            const alert = appState.settings.alerts.find(a => a.id === id);
            if (alert) {
                alert[field] = value;
                if (field === 'enabled') renderSettings(); 
            }
        };

        // NEW: Generic setting updater for non-alert settings
        window.updateGlobalSetting = (key, value) => {
            appState.settings[key] = value;
        };

        window.saveSettingsAndClose = () => {
            localStorage.setItem('av_settings', JSON.stringify(appState.settings));
            localStorage.setItem('av_layout', JSON.stringify(appState.layout));
            renderDashboard(); // Re-render the grid immediately
            toggleModal('modal-settings', false);
        };

        // --- MATH UTILS ---
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371e3; 
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lon2-lon1) * Math.PI/180;
            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        // --- IGC EXPORT UTILS ---
        function decimalToIGC(val, isLat) {
            const abs = Math.abs(val);
            const deg = Math.floor(abs);
            const min = (abs - deg) * 60;
            const degStr = deg.toString().padStart(isLat ? 2 : 3, '0');
            const minStr = Math.floor(min).toString().padStart(2, '0');
            const decMinStr = Math.floor((min % 1) * 1000).toString().padStart(3, '0');
            let hemi = '';
            if (isLat) hemi = val >= 0 ? 'N' : 'S';
            else hemi = val >= 0 ? 'E' : 'W';
            return `${degStr}${minStr}${decMinStr}${hemi}`;
        }

        function downloadLogIGC(startTime) {
            const logs = JSON.parse(localStorage.getItem('glider_flight_history') || '[]');
            const log = logs.find(l => l.startTime === startTime);
            if (!log || !log.route || log.route.length === 0) { alert("Sin datos de ruta"); return; }
            
            const dateObj = new Date(log.startTime);
            const dateStr = 
                ('0' + dateObj.getUTCDate()).slice(-2) + 
                ('0' + (dateObj.getUTCMonth()+1)).slice(-2) + 
                dateObj.getUTCFullYear().toString().slice(-2);
            
            // Header
            let igcContent = `AAVP001AeroVarioPro\r\nHFDTE${dateStr}\r\nHFPLTPILOTAeroVario User\r\nHFDTM100GPSDATUM WGS-84\r\n`;
            
            // B Records: B HHMMSS DDMMmmmN DDDMMmmmE A PPPPP GGGGG
            log.route.forEach(pt => {
                const t = new Date(pt.t || log.startTime); // fallback if track point has no time, theoretically fullTrack has 't'
                const hhmmss = 
                    ('0' + t.getUTCHours()).slice(-2) + 
                    ('0' + t.getUTCMinutes()).slice(-2) + 
                    ('0' + t.getUTCSeconds()).slice(-2);
                
                const latStr = decimalToIGC(pt.lat, true);
                const lonStr = decimalToIGC(pt.lon, false);
                const altStr = ('00000' + Math.round(pt.alt)).slice(-5); // Use GPS alt for Pressure too as fallback
                
                igcContent += `B${hhmmss}${latStr}${lonStr}A${altStr}${altStr}\r\n`;
            });

            const blob = new Blob([igcContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flight_${dateStr}.igc`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- GEOCODING UTIL ---
        async function fetchLocationName(lat, lon) {
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=12`);
                if(!res.ok) throw new Error("Net Err");
                const data = await res.json();
                const a = data.address;
                if(a) return a.village || a.town || a.city || a.hamlet || a.mountain_pass || a.county || "Zona de Vuelo";
                return data.display_name ? data.display_name.split(',')[0] : `${lat.toFixed(3)}, ${lon.toFixed(3)}`;
            } catch(e) { return `${lat.toFixed(3)}, ${lon.toFixed(3)}`; }
        }

        // --- METEO LOGIC ---
        function analyzeFlightConditions(wind, gusts, rain, cloudCover) {
            if (wind > 25) return { color: '#ef4444', status: 'PELIGRO', msg: "¬°PELIGRO! Viento >25km/h. NO DESPEGAR." };
            if (gusts > (wind + 15)) return { color: '#ef4444', status: 'PELIGRO', msg: "¬°PELIGRO! Turbulencia severa." };
            if (rain > 0) return { color: '#ef4444', status: 'LLUVIA', msg: "Lluvia detectada. Aterriza inmediatamente." };
            if (wind >= 20 && wind <= 25) return { color: '#facc15', status: 'PRECAUCI√ìN', msg: "Condiciones fuertes. Solo expertos." };
            if (gusts > (wind + 10)) return { color: '#facc15', status: 'RACHEADO', msg: "R√°fagas fuertes. Pilotaje activo." };
            if (cloudCover > 90) return { color: '#facc15', status: 'NO VISIBILIDAD', msg: "Cielo cubierto. Riesgo ODN." };
            if (wind < 5) return { color: '#3b82f6', status: 'D√âBIL', msg: "Viento suave. Despegue a carrera." };
            return { color: '#a3e635', status: 'IDEAL', msg: "Condiciones excelentes." };
        }

        async function fetchMeteoData() {
            const content = $('meteo-data'); const loading = $('meteo-loading');
            loading.style.display = 'block'; content.classList.add('hidden');
            $('meteo-location-display').innerText = "üìç Localizando nombre...";
            if(!navigator.geolocation) { loading.innerText = "GPS no disponible"; return; }

            navigator.geolocation.getCurrentPosition(async (pos) => {
                const lat = pos.coords.latitude; const lon = pos.coords.longitude;
                try {
                    const locName = await fetchLocationName(lat, lon);
                    $('meteo-location-display').innerText = "üìç " + locName;
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,cloud_cover,precipitation&wind_speed_unit=kmh`;
                    const res = await fetch(url);
                    if(!res.ok) throw new Error("API Err");
                    const json = await res.json();
                    const cur = json.current;
                    $('val-wind').innerText = cur.wind_speed_10m;
                    $('val-gusts').innerText = cur.wind_gusts_10m;
                    $('val-temp').innerText = cur.temperature_2m;
                    $('val-cloud').innerText = cur.cloud_cover;
                    const rot = cur.wind_direction_10m + 180; 
                    $('wind-arrow').style.transform = `rotate(${rot}deg)`;
                    const analysis = analyzeFlightConditions(cur.wind_speed_10m, cur.wind_gusts_10m, cur.precipitation, cur.cloud_cover);
                    $('expert-bar-fill').style.backgroundColor = analysis.color;
                    $('expert-text').innerText = analysis.msg;
                    $('expert-text').style.color = analysis.color === '#facc15' ? '#fef08a' : analysis.color;
                    loading.style.display = 'none'; content.classList.remove('hidden');
                } catch(e) { loading.innerText = "Error cargando meteo."; }
            }, (err) => { loading.innerText = "Error GPS."; });
        }

        // --- LOGS LOGIC ---
        function renderLogs() {
            const container = $('logs-list'); container.innerHTML = '';
            const logs = JSON.parse(localStorage.getItem('glider_flight_history') || '[]');
            if(logs.length === 0) { container.innerHTML = '<div style="text-align:center; color:#666; margin-top:20px;">No hay vuelos registrados</div>'; return; }

            logs.sort((a,b) => b.startTime - a.startTime).forEach((log, index) => {
                const dateStr = new Date(log.startTime).toLocaleDateString();
                const timeStr = new Date(log.startTime).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                const durH = Math.floor(log.totalTime / 3600);
                const durM = Math.floor((log.totalTime % 3600) / 60);
                const durS = Math.floor(log.totalTime % 60);
                const durationFmt = `${durH>0 ? ('0'+durH).slice(-2)+':' : ''}${('0'+durM).slice(-2)}:${('0'+durS).slice(-2)}`;
                
                const startTimeFmt = new Date(log.startTime).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
                const endTimeFmt = new Date(log.endTime).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});

                const distKm = (log.totalDistance / 1000).toFixed(2);
                const locDisplay = log.location ? `üìç ${log.location}` : '';

                const html = `
                <div class="log-item">
                    <div class="log-summary" onclick="toggleLogDetails(${index})">
                        <div>
                            <div class="log-date">${dateStr} <span style="font-weight:normal; font-size:0.8em; color:#666">${timeStr}</span>${locDisplay ? `<div style="font-size:0.75rem; color:var(--neon-green); margin-top:2px;">${locDisplay}</div>` : ''}</div>
                            <div class="log-basic-stats"><span>‚è±Ô∏è ${durationFmt}</span><span>üìè ${distKm} km</span></div>
                        </div>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <span style="color:var(--neon-green)">+${(log.totalAscent || log.gain).toFixed(0)}m</span>
                            <button class="btn-delete-log" onclick="event.stopPropagation(); deleteLog(${log.startTime})">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div id="log-det-${index}" class="log-details">
                        
                        <h4 class="stats-section-title">Estad√≠sticas b√°sicas</h4>
                        <div class="stats-grid-2col">
                            <div class="stat-item"><div class="stat-val">${startTimeFmt}</div><div class="stat-lbl">üïí despegue</div></div>
                            <div class="stat-item"><div class="stat-val">${endTimeFmt}</div><div class="stat-lbl">üïí aterrizaje</div></div>
                            <div class="stat-item"><div class="stat-val">${durationFmt}</div><div class="stat-lbl">‚è±Ô∏è duraci√≥n</div></div>
                            <div class="stat-item"><div class="stat-val">${distKm} km</div><div class="stat-lbl">üìè distancia</div></div>
                            <div class="stat-item"><div class="stat-val">${log.maxSpeed} km/h</div><div class="stat-lbl">üí® vel. m√°xima</div></div>
                            <div class="stat-item"><div class="stat-val">${log.minSpeed || 0} km/h</div><div class="stat-lbl">üí® vel. m√≠nima</div></div>
                            <div class="stat-item"><div class="stat-val">${log.avgSpeed} km/h</div><div class="stat-lbl">üí® vel. media</div></div>
                        </div>

                        <h4 class="stats-section-title">Estad√≠sticas verticales</h4>
                        <div class="stats-grid-2col">
                            <div class="stat-item"><div class="stat-val">${log.takeoffAlt} m</div><div class="stat-lbl">‚õ∞Ô∏è altitud inicial</div></div>
                            <div class="stat-item"><div class="stat-val">${log.landingAlt || '--'} m</div><div class="stat-lbl">‚õ∞Ô∏è altitud aterrizaje</div></div>
                            <div class="stat-item"><div class="stat-val text-green-400">${log.maxClimb} m/s</div><div class="stat-lbl">üìà tasa m√°x. ascenso</div></div>
                            <div class="stat-item"><div class="stat-val text-red-400">${log.maxSink} m/s</div><div class="stat-lbl">üìâ tasa m√°x. descenso</div></div>
                            <div class="stat-item"><div class="stat-val">${log.maxAlt} m</div><div class="stat-lbl">‚¨ÜÔ∏è altitud m√°xima</div></div>
                            <div class="stat-item"><div class="stat-val">${log.minAlt || log.takeoffAlt} m</div><div class="stat-lbl">‚¨áÔ∏è altitud m√≠nima</div></div>
                            <div class="stat-item"><div class="stat-val">${(log.totalAscent || 0).toFixed(0)} m</div><div class="stat-lbl">‚ÜóÔ∏è ascenso total</div></div>
                            <div class="stat-item"><div class="stat-val">${(log.totalDescent || 0).toFixed(0)} m</div><div class="stat-lbl">‚ÜòÔ∏è descenso total</div></div>
                            <div class="stat-item"><div class="stat-val">${((log.landingAlt || 0) - log.takeoffAlt).toFixed(0)} m</div><div class="stat-lbl">‚ÜïÔ∏è diferencial</div></div>
                        </div>

                        ${(log.route && log.route.length > 0) ? `
                            <button class="btn-map-view" onclick="viewFlightMap(${log.startTime})">üó∫Ô∏è Ver Mapa</button>
                            <button class="btn-download-igc" onclick="downloadLogIGC(${log.startTime})">üì• Descargar IGC</button>
                        ` : ''}
                    </div>
                </div>`;
                container.innerHTML += html;
            });
            container.innerHTML += `<button class="btn-delete-all" onclick="deleteAllLogs()">‚ö†Ô∏è Borrar Todo</button>`;
        }
        
        window.toggleLogDetails = (idx) => { const el = $(`log-det-${idx}`); el.style.display = el.style.display === 'block' ? 'none' : 'block'; };
        window.deleteLog = (timestamp) => { if(confirm("¬øEliminar vuelo?")) { let logs = JSON.parse(localStorage.getItem('glider_flight_history') || '[]'); logs = logs.filter(l => l.startTime !== timestamp); localStorage.setItem('glider_flight_history', JSON.stringify(logs)); renderLogs(); } };
        window.deleteAllLogs = () => { if(confirm("¬øBorrar TODOS?")) { localStorage.removeItem('glider_flight_history'); renderLogs(); } };
        
        // --- REVIEW MAP LOGIC ---
        let reviewMap = null;
        window.viewFlightMap = (startTime) => {
            const logs = JSON.parse(localStorage.getItem('glider_flight_history') || '[]');
            const log = logs.find(l => l.startTime === startTime);
            if(!log || !log.route || log.route.length === 0) { alert("No hay ruta."); return; }
            $('modal-review').classList.remove('hidden');
            if(reviewMap) { reviewMap.remove(); reviewMap = null; }
            setTimeout(() => {
                reviewMap = L.map('review-map-container', { attributionControl: false }).setView([0,0], 10);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(reviewMap);
                const latlngs = log.route.map(p => [p.lat, p.lon]);
                const polyline = L.polyline(latlngs, { color: '#06b6d4', weight: 5, opacity: 0.9 }).addTo(reviewMap);
                L.circleMarker(latlngs[0], { color: '#a3e635', radius: 6, fillOpacity: 1 }).bindPopup('Despegue').addTo(reviewMap);
                L.circleMarker(latlngs[latlngs.length-1], { color: '#ef4444', radius: 6, fillOpacity: 1 }).bindPopup('Aterrizaje').addTo(reviewMap);
                reviewMap.fitBounds(polyline.getBounds(), { padding: [50, 50] });
            }, 100);
        };
        window.closeReviewMap = () => { $('modal-review').classList.add('hidden'); if(reviewMap) { reviewMap.remove(); reviewMap = null; } };

        function endFlight() {
            if (!appState.flying) return;
            if(flightTimerInterval) clearInterval(flightTimerInterval);
            const endTime = Date.now();
            const totalTimeSec = (endTime - appState.startTime) / 1000;
            
            if (totalTimeSec > 10 && appState.fullTrack.length > 1) {
                let totalDist = 0;
                let totalAscent = 0;
                let totalDescent = 0;
                let minAlt = 99999;
                let landingAlt = 0;
                let minSpeed = 999;

                // Loop track to calculate detailed stats
                if (appState.fullTrack.length > 0) {
                    minAlt = appState.fullTrack[0].alt;
                    landingAlt = appState.fullTrack[appState.fullTrack.length-1].alt;
                }

                for(let i=1; i<appState.fullTrack.length; i++) {
                    const p1 = appState.fullTrack[i-1];
                    const p2 = appState.fullTrack[i];
                    
                    // Distance
                    const distSeg = haversine(p1.lat, p1.lon, p2.lat, p2.lon);
                    totalDist += distSeg;
                    
                    // Vertical
                    const diffAlt = p2.alt - p1.alt;
                    if (diffAlt > 0) totalAscent += diffAlt;
                    else totalDescent += Math.abs(diffAlt);

                    if (p2.alt < minAlt) minAlt = p2.alt;

                    // Calc instantaneous speed between points approx (m/s -> km/h)
                    const timeDiff = (p2.t - p1.t) / 1000;
                    if (timeDiff > 0) {
                        const spd = (distSeg / timeDiff) * 3.6;
                        if (spd < minSpeed && spd > 1) minSpeed = spd; // ignore near 0 noise
                    }
                }
                
                if (minSpeed === 999) minSpeed = 0;

                const startPt = appState.fullTrack[0];
                const linearDist = haversine(startPt.lat, startPt.lon, appState.fullTrack[appState.fullTrack.length-1].lat, appState.fullTrack[appState.fullTrack.length-1].lon);
                
                const flightLog = {
                    startTime: appState.startTime, endTime: endTime, totalTime: totalTimeSec,
                    totalDistance: Math.round(totalDist), linearDistance: Math.round(linearDist),
                    maxSpeed: Math.round(appState.stats.maxSpeed), 
                    minSpeed: Math.round(minSpeed),
                    avgSpeed: parseFloat(((totalDist/totalTimeSec)*3.6).toFixed(1)),
                    takeoffAlt: Math.round(startPt.alt), 
                    landingAlt: Math.round(landingAlt),
                    maxAlt: appState.stats.maxAlt, 
                    minAlt: Math.round(minAlt),
                    gain: Math.max(0, appState.stats.maxAlt - Math.round(startPt.alt)),
                    totalAscent: totalAscent,
                    totalDescent: totalDescent,
                    maxClimb: appState.stats.maxClimb.toFixed(1), maxSink: appState.stats.maxSink.toFixed(1),
                    location: appState.startLocation || "Desconocido",
                    route: appState.fullTrack.map(p => ({ lat: parseFloat(p.lat.toFixed(5)), lon: parseFloat(p.lon.toFixed(5)), a: Math.round(p.alt), t: p.t }))
                };
                const logs = JSON.parse(localStorage.getItem('glider_flight_history') || '[]');
                logs.push(flightLog);
                localStorage.setItem('glider_flight_history', JSON.stringify(logs));
            }
            location.reload();
        }

        // --- GRAPH LOGIC ---
        const altGraphCanvas = $('alt-graph');
        const altGraphCtx = altGraphCanvas.getContext('2d');
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const graphParent = altGraphCanvas.parentElement;
            altGraphCanvas.width = graphParent.clientWidth * dpr;
            altGraphCanvas.height = graphParent.clientHeight * dpr;
            altGraphCtx.scale(dpr, dpr);
            altGraphCanvas.logicalWidth = graphParent.clientWidth;
            altGraphCanvas.logicalHeight = graphParent.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        
        function drawAltGraph() {
            if (!appState.flying) return;
            const w = altGraphCanvas.logicalWidth; const h = altGraphCanvas.logicalHeight; const ctx = altGraphCtx;
            const axisWidth = 35; // Reserved space for Y axis labels on the left
            const graphW = w - axisWidth;

            ctx.clearRect(0, 0, w, h);
            const data = appState.altHistory;
            if(data.length < 2) return;
            
            let min = Infinity, max = -Infinity;
            for(let v of data) { if(v < min) min = v; if(v > max) max = v; }
            
            // Add padding to range
            const range = max - min; 
            const pad = (range === 0) ? 10 : range * 0.2; 
            min -= pad; max += pad;
            
            // Draw Axis Labels (in the reserved left area)
            ctx.fillStyle = '#666'; ctx.font = '10px monospace'; ctx.textAlign = 'right';
            ctx.fillText(Math.round(max), axisWidth - 5, 12); 
            ctx.fillText(Math.round(min), axisWidth - 5, h - 5);
            
            // Draw Axis Line
            ctx.beginPath(); ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
            ctx.moveTo(axisWidth, 0); ctx.lineTo(axisWidth, h); ctx.stroke();

            // Draw Graph Area
            ctx.beginPath(); ctx.strokeStyle = '#a3e635'; ctx.lineWidth = 2;
            
            // We map 120 points to the graph width
            const stepX = graphW / 119; 
            
            for(let i=0; i<data.length; i++) {
                const x = axisWidth + (i * stepX); 
                const norm = (data[i] - min) / (max - min); 
                const y = h - (norm * h);
                if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Close path for fill
            ctx.lineTo(axisWidth + (data.length-1)*stepX, h); 
            ctx.lineTo(axisWidth, h); // go back to start X at bottom
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(163, 230, 53, 0.1)'; 
            ctx.fill();
        }

        // --- KALMAN & FLIGHT LOGIC ---
        class KalmanFilter {
            constructor(R=1, Q=10) { this.R=R; this.Q=Q; this.x=NaN; this.p=NaN; }
            filter(z) {
                if(isNaN(this.x)) { this.x=z; this.p=this.Q; return z; }
                let pp = this.p + this.R; let k = pp / (pp + this.Q);
                this.x = this.x + k * (z - this.x); this.p = (1-k) * pp;
                return this.x;
            }
        }
        const altFilter = new KalmanFilter(0.5, 15);
        let altHistory = []; let sinkStartTime = 0, lastAlertTime = 0;

        function processFlightData(coords, timestamp) {
            const rawAlt = coords.altitude || 0;
            const filteredAlt = altFilter.filter(rawAlt);
            
            // If calibrating, collect data for auto-zero but do not proceed with flight stats
            if (appState.calibrating) {
                appState.calibrationBuffer.push(filteredAlt);
                // Also update map with current position so user sees where they are, but don't draw track
                updateMap(coords.latitude, coords.longitude, 0);
                return;
            }

            altHistory.push({ t: timestamp, alt: filteredAlt });
            altHistory = altHistory.filter(p => timestamp - p.t < 2000);
            let vario = 0;
            if (altHistory.length >= 2) { vario = (altHistory[altHistory.length-1].alt - altHistory[0].alt) / ((altHistory[altHistory.length-1].t - altHistory[0].t)/1000); }

            const speedKmh = (coords.speed || 0) * 3.6;
            let glide = 0;
            if (vario < -0.5 && speedKmh > 5) glide = Math.abs((speedKmh/3.6)/vario);
            
            let finalHeading = 0;
            if (speedKmh > 5 && coords.heading && !isNaN(coords.heading)) { finalHeading = coords.heading; } 
            else if (appState.sensors.magHeading !== null) { finalHeading = appState.sensors.magHeading; } 
            else if (coords.heading && !isNaN(coords.heading)) { finalHeading = coords.heading; }
            appState.flightData.heading = finalHeading;

            // Only update takeoff alt if it wasn't set by calibration (fallback)
            if (appState.takeoffAlt === null) appState.takeoffAlt = filteredAlt;
            
            appState.flightData.alt = Math.round(filteredAlt);
            appState.flightData.relAlt = Math.round(filteredAlt - appState.takeoffAlt);
            appState.flightData.vario = parseFloat(vario.toFixed(1));
            appState.flightData.speed = Math.round(speedKmh);
            appState.flightData.glide = glide > 0 && glide < 50 ? glide.toFixed(1) : '--';
            appState.flightData.lat = coords.latitude; appState.flightData.lon = coords.longitude;
            appState.stats.maxAlt = Math.max(appState.stats.maxAlt, appState.flightData.alt);
            appState.stats.maxClimb = Math.max(appState.stats.maxClimb, vario);
            appState.stats.maxSink = Math.min(appState.stats.maxSink, vario);
            appState.stats.maxSpeed = Math.max(appState.stats.maxSpeed, speedKmh);
            appState.altHistory.push(filteredAlt);
            if(appState.altHistory.length > 120) appState.altHistory.shift();

            if (coords.latitude && coords.longitude) {
                if (!appState.lastOdometerPos) { appState.lastOdometerPos = { lat: coords.latitude, lon: coords.longitude }; } 
                else {
                     const dist = haversine(appState.lastOdometerPos.lat, appState.lastOdometerPos.lon, coords.latitude, coords.longitude);
                     if (dist > 5) { appState.flightData.totalDistance += dist; appState.lastOdometerPos = { lat: coords.latitude, lon: coords.longitude }; }
                }
                const lastLogPt = appState.fullTrack[appState.fullTrack.length-1];
                let shouldLog = true;
                if(lastLogPt) { if(Math.abs(coords.latitude - lastLogPt.lat) < 0.0001 && Math.abs(coords.longitude - lastLogPt.lon) < 0.0001) shouldLog = false; }
                if(shouldLog) { appState.fullTrack.push({ lat: coords.latitude, lon: coords.longitude, alt: filteredAlt, t: Date.now() }); }
                updateMap(coords.latitude, coords.longitude, vario);
                
                // --- WIND ESTIMATION UPDATE ---
                // Only if we have wind estimator
                if (appState.windEstimator) {
                    appState.windEstimator.add(finalHeading, speedKmh, Date.now());
                    const wind = appState.windEstimator.estimate();
                    updateWindWidget(wind);
                } else {
                    appState.windEstimator = new WindEstimator();
                }
            }
            updateUI();
            
            // --- UPDATE NEW IOS COMPASS ---
            // Just need to ensure magHeading is up to date, the animation loop handles the visual rotation.
            // appState.sensors.magHeading is updated by 'deviceorientation' or GPS

            drawAltGraph(); audio.update(vario); checkAlerts(appState.flightData);
        }

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() { this.ctx=null; this.osc=null; this.isBeeping=false; }
            init() { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); this.gain = this.ctx.createGain(); this.gain.connect(this.ctx.destination); }
            playTone(freq, type, dur) {
                if(!this.ctx) return;
                const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
                o.type=type; o.frequency.value=freq; o.connect(g); g.connect(this.gain);
                g.gain.value=0; g.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime+0.05);
                o.start(); if(dur) { g.gain.linearRampToValueAtTime(0, this.ctx.currentTime+dur); o.stop(this.ctx.currentTime+dur+0.1); }
                return {o, g};
            }
            update(vario) {
                if(appState.muted || appState.calibrating) return; // Mute during calibration
                const liftThresh = appState.settings.liftThreshold || 0.2;
                const sinkThresh = appState.settings.sinkThreshold || -2.0;

                if(vario < sinkThresh) { this.stopBeep(); if(!this.osc) { const s=this.playTone(200, 'sawtooth'); this.osc=s.o; } if(this.osc) this.osc.frequency.value = Math.max(100, 300 + (vario*50)); } 
                else if(vario > liftThresh) { if(this.osc) { this.osc.stop(); this.osc=null; } if(!this.isBeeping) { this.isBeeping=true; this.scheduleBeep(vario); } } 
                else { this.stopAll(); }
            }
            scheduleBeep(vario) {
                if(!this.isBeeping) return;
                const v = Math.min(vario, 8); const period = Math.max(150, 600 - (v*60));
                this.playTone(400+(v*100), 'square', period*0.5/1000);
                this.timer = setTimeout(() => this.scheduleBeep(appState.flightData.vario), period);
            }
            stopBeep() { this.isBeeping=false; clearTimeout(this.timer); }
            stopAll() { this.stopBeep(); if(this.osc){try{this.osc.stop();}catch(e){} this.osc=null;} }
            playAlert(type) {
                if(appState.muted || appState.calibrating) return; this.stopAll();
                const now = this.ctx.currentTime;
                if(type === 'beep') { const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type='square'; o.frequency.value=1500; o.connect(g); g.connect(this.gain); g.gain.setValueAtTime(0.3, now); g.gain.setValueAtTime(0, now+0.1); g.gain.setValueAtTime(0.3, now+0.2); g.gain.setValueAtTime(0, now+0.3); o.start(now); o.stop(now+0.3); } 
                else if(type === 'whoop') { const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type='sine'; o.connect(g); g.connect(this.gain); o.frequency.setValueAtTime(300, now); o.frequency.exponentialRampToValueAtTime(1200, now+0.4); g.gain.setValueAtTime(0.5, now); g.gain.exponentialRampToValueAtTime(0.01, now+0.4); o.start(now); o.stop(now+0.4); }
                else { this.playTone(800, 'triangle', 0.6); }
            }
        }
        const audio = new AudioEngine();

        // --- UI & UTILS ---
        function updateUI() {
            const d = appState.flightData;
            
            // 1. Digital Vario
            const valVario = $('value-vario');
            if (valVario) {
                valVario.innerText = (d.vario>0?'+':'') + d.vario.toFixed(1);
                valVario.className = d.vario > 0.1 ? 'climbing' : (d.vario < -0.1 ? 'sinking' : '');
            }

            // 2. Horizon / Compass - Updated via animateCompass Loop

            // 3. Dynamic Slots
            const elAlt = $('value-alt'); if(elAlt) elAlt.innerText = d.alt;
            const elRel = $('value-rel-alt'); if(elRel) elRel.innerText = d.relAlt;
            const elSpd = $('value-speed'); if(elSpd) elSpd.innerText = d.speed;
            const elGld = $('value-glide'); if(elGld) elGld.innerText = d.glide;
            const elDist = $('value-dist'); if(elDist) elDist.innerText = (d.totalDistance / 1000).toFixed(1);
            const elHdg = $('value-hdg'); if(elHdg) elHdg.innerText = Math.round(d.heading);

            // 4. Vario Bar
            const max=5, val=Math.max(-max, Math.min(max, d.vario));
            const bar=$('vario-fill');
            if(val>0) { bar.style.bottom='50%'; bar.style.top='auto'; bar.style.height=(val/max*50)+'%'; bar.style.background='var(--neon-green)'; }
            else { bar.style.top='50%'; bar.style.bottom='auto'; bar.style.height=(Math.abs(val)/max*50)+'%'; bar.style.background='var(--neon-red)'; }
        }

        function checkAlerts(data) {
            if (appState.calibrating) return; // No alerts during calibration
            const now = Date.now();
            let activeAlert = null; let soundToPlay = null;
            appState.settings.alerts.forEach(a => {
                if(!a.enabled) return;
                if(a.type === 'ALTITUDE_LOW' && data.alt < a.threshold && data.alt > 0) { if (now - lastAlertTime > 5000) { activeAlert='BAJA ALTITUD'; soundToPlay = a.sound; } }
                if(a.type === 'SINK_RATE') {
                    if (data.vario < a.threshold) {
                         if (!sinkStartTime) sinkStartTime = now;
                         else if ((now - sinkStartTime)/1000 > (a.duration || 2)) { if (now - lastAlertTime > 3000) { activeAlert='DESCENSO FUERTE'; soundToPlay = a.sound; } }
                    } else { if (data.vario > a.threshold) sinkStartTime = 0; }
                }
            });
            if(activeAlert && soundToPlay) { $('alert-overlay').innerText='‚ö†Ô∏è '+activeAlert; $('alert-overlay').style.display='block'; audio.playAlert(soundToPlay); lastAlertTime=now; setTimeout(()=>$('alert-overlay').style.display='none', 2500); }
        }

        // --- CALIBRATION LOGIC ---
        function startCalibrationCountdown() {
            let progress = 0;
            const bar = $('cal-bar');
            const interval = setInterval(() => {
                progress += 2; // 50 steps * 100ms = 5000ms
                if (bar) bar.style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(interval);
                    finishCalibration();
                }
            }, 100);
        }

        function finishCalibration() {
            // Auto-Zero: Calculate average altitude from buffer
            if (appState.calibrationBuffer.length > 0) {
                const sum = appState.calibrationBuffer.reduce((a, b) => a + b, 0);
                const avg = sum / appState.calibrationBuffer.length;
                appState.takeoffAlt = avg;
                console.log("Calibration complete. Takeoff Alt set to: " + avg.toFixed(1) + "m");
            } else {
                // Fallback if no GPS data yet
                console.warn("Calibration finished but no GPS data.");
                appState.takeoffAlt = 0; 
            }

            // Switch State
            appState.calibrating = false;
            appState.flying = true;
            appState.startTime = Date.now();
            
            // Hide Overlay
            $('calibration-overlay').classList.add('hidden');
            
            // Ready Sound
            audio.playTone(800, 'sine', 0.1);
            setTimeout(() => audio.playTone(1200, 'sine', 0.1), 150);
            setTimeout(() => audio.playTone(1600, 'sine', 0.2), 300);
            
            // Start Timer
            if(flightTimerInterval) clearInterval(flightTimerInterval);
            flightTimerInterval = setInterval(updateFlightClock, 1000);
        }

        function initFlightSystem() {
            audio.init();
            initMap();
            isMapCentered = false;
            renderDashboard();
            manageWakeLock(true);
            
            // Reset State for fresh flight
            appState.flying = false; // Not flying yet, waiting for cal
            appState.calibrating = true; 
            appState.stats = { maxAlt: -9999, maxClimb: 0, maxSink: 0, maxSpeed: 0 };
            appState.fullTrack = []; appState.altHistory = []; appState.startLocation = null; 
            appState.mapThermalMarkers = []; appState.flightData.totalDistance = 0; appState.lastOdometerPos = null;
            appState.calibrationBuffer = [];
            // Init Wind Estimator
            appState.windEstimator = new WindEstimator();

            if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function') {
                 try { DeviceOrientationEvent.requestPermission().then(response => { if(response === 'granted') { startSensors(); } }); } catch(e){}
            } else { startSensors(); }

            // Switch Screen
            $('screen-start').classList.add('hidden');
            $('screen-hud').classList.remove('hidden'); $('screen-hud').classList.add('flex');
            resizeCanvas(); 

            // Show Calibration Overlay
            $('calibration-overlay').classList.remove('hidden');
            $('cal-bar').style.width = '0%';
            startCalibrationCountdown();
            
            if('geolocation' in navigator) {
                $('gps-status').innerText = "GPS: Buscando...";
                navigator.geolocation.watchPosition(
                    pos => {
                        $('gps-status').innerText = "GPS: OK"; $('gps-status').style.color='var(--neon-green)';
                        const acc = pos.coords.accuracy || 50;
                        const sats = acc <= 5 ? 12 : (acc <= 10 ? 10 : (acc <= 20 ? 7 : 4));
                        const satEl = $('sat-status'); satEl.innerText = `SAT: ${sats}`; satEl.style.color = sats >= 10 ? 'var(--neon-green)' : (sats >= 7 ? '#eab308' : 'var(--text-gray)');
                        if (!appState.startLocation && acc < 100) { appState.startLocation = "Obteniendo..."; fetchLocationName(pos.coords.latitude, pos.coords.longitude).then(loc => appState.startLocation = loc); }
                        processFlightData(pos.coords, pos.timestamp);
                    },
                    err => { $('gps-status').innerText = "GPS Error"; $('gps-status').style.color='var(--neon-red)'; $('gps-status').classList.add('error-clickable'); $('gps-status').onclick = () => location.reload(); },
                    { enableHighAccuracy: true, maximumAge: 0 }
                );
            }
        }

        function startSensors() {
            window.addEventListener('deviceorientation', (e) => {
                // 1. Compass (Heading)
                if (e.webkitCompassHeading) { 
                    appState.sensors.magHeading = e.webkitCompassHeading; 
                    $('compass-status').innerText = "MAG: OK"; $('compass-status').style.color = 'var(--neon-green)'; 
                } else if (e.alpha !== null) { 
                    appState.sensors.magHeading = 360 - e.alpha; 
                    $('compass-status').innerText = "MAG: OK"; 
                }

                // 2. Horizon (Pitch/Roll)
                if (e.beta !== null) appState.sensors.pitch = e.beta;
                if (e.gamma !== null) appState.sensors.roll = e.gamma;
            });
        }

        $('btn-start').addEventListener('click', initFlightSystem);
        $('btn-stop').addEventListener('click', endFlight);
        $('btn-logs').addEventListener('click', () => toggleModal('modal-logs', true));
        $('btn-meteo').addEventListener('click', () => { toggleModal('modal-meteo', true); fetchMeteoData(); });
        $('btn-mute').addEventListener('click', () => { appState.muted = !appState.muted; $('btn-mute').innerText = appState.muted ? 'üîá' : 'üîä'; });
        $('btn-settings').addEventListener('click', () => toggleModal('modal-settings', true));
        
        function resetAlt() { appState.takeoffAlt = appState.flightData.alt; }
        function toggleModal(id, s) { 
            $(id).className = s ? 'modal-overlay' : 'hidden'; 
            if(s && id==='modal-settings') renderSettings(); 
            if(s && id==='modal-logs') renderLogs();
        }
        
        for(let i=1; i<=4; i++) { $('ticks-container').innerHTML += `<div class="tick" style="top:${50-i*10}%"></div><div class="tick" style="top:${50+i*10}%"></div>`; }
        
        // Initial Render of Dashboard (Empty or Default)
        renderDashboard();
    </script>
</body>
</html>
